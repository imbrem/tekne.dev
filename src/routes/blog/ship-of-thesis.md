---
title: Adventures in Type Theory 4 — The Ship of Thesis
published: '2025-09-30'
---
_Location_: [FS04, William Gates Building](https://maps.app.goo.gl/vE5oxXW5XHdiGybq5) (52.210434,
0.091859)

_Time_: 2025-09-30T14:00+1

It's been a long journey!

The type theory starts after the _Prelude_ section.

# Prelude

_Location_: [Darwin College](https://maps.app.goo.gl/DwNTqaDdy8GZeMAd7) (52.20035, 0.11422)

We set sail from [Termini Imerese](https://maps.app.goo.gl/9CGy7299J77gDpKF6) to the island of
[Vulcano](https://en.wikipedia.org/wiki/Vulcano)[^1]. Well, we sailed part of the way, but after
making the mistake of letting me at the wheel, we had to switch to the engine...

<div style="text-align: center">
<img src={boat_circle} alt="The path of the boat with me at the wheel... a loop!" style="max-width: 70%" />
</div>

Anyways. From there, we move on to the island of [Lipari](https://en.wikipedia.org/wiki/Lipari),
where we part ways, with the rest of the crew going to
[Stromboli](https://en.wikipedia.org/wiki/Stromboli). It was time to get somewhere with better
Internet.

I took the ferry back to [Messina](https://en.wikipedia.org/wiki/Messina), and from there, the train
back to Termini Imerese. On the long march to the train station, I think locally nameless thoughts.
It was time for another attempt at the `covalence` theorem prover, as the end of my PhD loomed. So I
try formalizing the new type theory, this time with cumulative universes and a new approach fusing
locally-nameless style with the indexed term types of
[`logrel-mltt`](https://github.com/mr-ohman/logrel-mltt). At the same time, much meditation on SSA
occurred.

I arrive at Termini Imerese and ride my bike _back_ to Messina, where I stay at the wonderful [La
Badia Bed and Room](https://hotelmania.net/hotel/mesina/la-badia-2/). I arrive at 1 AM, much later
than planned, as I got lost on the way and had to find gas. Thankfully, the owner finds me at the
door and, though I don't have cash, allows me to stay, with a promise to go find an ATM the next
morning and pay.

The owner is a jovial psychiatrist who helps youth with addiction issues, and offers me numerous
coffees. I, of course, accept these, and then head out into the city to find cash and breakfast.
Tempted by the seafood available at the [local
supermarket](https://maps.app.goo.gl/J56836HjAMpBytREA), I decide to stay another night.

<div style="text-align: center">
<img src={conad_seafood} alt="That fish like this is available at a regular supermarket..." style="max-width: 70%" />
</div>

I leave the next day, having laid down the bones for what I'm calling [Gödel-Tarski Type
Theory](https://github.com/imbrem/gt3-lean), or GT3, and make for
[Balzano](https://maps.app.goo.gl/dNTWgKJ6aAstbMC36) in Calabria, where my mother's mother's family
lives. There, I receive free food, free board, and poor, but better than shipboard, Internet. And I
also encounter the lowest density of English speakers I've seen in my life, so far. Almost everyone
speaks only Italian.

This provided the perfect environment to get some work done. A little thesis, and a lot of theorem
proving later, and GT3 is taking shape and nearly ready for implementation. I take the time to plan
out my next steps in general. But all good things come to an end, and eventually, it is time to head
northwards, and back to work. To make sure I actually get there on time, I book some sushi with a
good friend of mine in London at 2025-09-19T18:00+1. A precise arrival date does wonders for trip
planning.

I make for Rome, where, carrying what I thought was most of GT3. I get distracted at the gas
station, and the night deepens, so, at 1:30 AM or so, I decide to stop at the neighboring city of
Aquina. As a first shot, I make for (La Vecchia Quercia)[https://maps.app.goo.gl/6xvSN7VuARrSBbXu5],
but I'm too late. Most of the places I call are closed, or expensive, and at this point, being 2:30
AM, I'd be buying just a few hours of quality sleep.

So I decide to do some science and just sleep in the field. It's warm, right.

Verdict: uncomfortable, due to rocks, and the occasional chill. But very doable in Italian summer
weather.

Up, and onwards. My charger is broken, so I need to get a new one. Charging up my navigator before
that in the city, we continue down to Rome, where I plan to meet a friend from Cambridge who's
passing through for a conference. It's a confusing place: all roads lead there, so once you get
there, the roads just lead to themselves, and you're completely free. It's a sad day, when you
understand the quote

> _Freedom is an ocean. You can drown in it._

But there is no victory without sacrifice. It is only through that sadness, that the happiness of
self-actualization, of true freedom, can be reached.

That's what I keep telling myself about graduation, anyways.

I stay at the powerfully-named [Happy Village e Camping
Roma](https://maps.app.goo.gl/YSRQpQdWkDjhKh8U6). After a day of food, sightseeing, and
formalization (I realized that I forgot to add the natural numbers to GT3...), it's time to bounce.

<div style="text-align: center">
<img src={roman_pasta} alt="Everything is improved by programming, but does programming improve everything?" style="max-width: 70%" />
</div>

I make for Milan, but _once again_ I fall prey to the temptations of the gas station. So I take a
detour to Bologna, where I hope to meet [Vikraman](https://vikraman.org/), which is always an
excellent experience. Alas, he has left for the UK the _previous day_. Such is fate!

Armed with only his list of recommendations, I translate into the mountains near Bologna, through
freezing mists, and arrive at the [B&B Nina](https://maps.app.goo.gl/UHVus6tCZ3V26iqU9) at 3 AM. The
host is exceedingly hospitable, and, spared from roughing it in the mountains, I fall deep into
hypersleep, gathering strength to face the morrow.

I spend a quiet day working on GT3 and tapping here and there at some locally-nameless SSA ideas.
Night falls once more, and the clock is ticking to return to Cambridge. So I make for Milan once
more, stopping at a local restaurant on the way. And, almost a month later, I find myself once more
at the [Idea Hotel Milano San Siro](https://sansiro.ideahotel.it/).

The sun rises, and I burn rubber on the road to Switzerland. _Elas!_ At the very final gas station
between Italy and Switzerland, I am once more waylaid by that ever crafty opponent, myself! Ah, the
ruses of the French!

A good friend from Toronto and I spend the day there on the phone, discussing `covalence`,
mathematical superintelligence (I am very excited about [https://harmonic.fun/](Harmonic)... we need
to integrate Aristotle with `covalence`, or something...), game theory, and other fun topics.

But then it is 9 PM and the Alps await. And I do not want to bankrupt myself finding a hotel in
Switzerland.

I was so excited to see the Alps in the day. It will have to wait till next time, elas. Through the
inky dark, a point of light flies.

Adventures ensue. I get held up in front of a closed tunnel, and my clutch starts acting up again
(but, thankfully, the bike still works). And so it is nearly 4 AM when, exhausted, I find myself
back in Mulhouse, at the [B&B](https://maps.app.goo.gl/cV1V3x5qh5nuKmiw9) I had originally booked
before the drain plug incident.

The morning comes once more, and I meet with Neel. He's excited about `covalence`, and we discuss
thesis plans. I get some [Indian food](https://maps.app.goo.gl/ZZgyocZV7dTnk5QXA) and ride on over
back to [Seedz Motorsport](https://maps.app.goo.gl/HeNfkWqqq5uGsHKM7) to discuss clutch and refunds.
They couldn't find anything wrong with the clutch (which was strange: I definitely noticed it
slipping, but just at high RPM, usually on a hill; even lugging it at low RPM was/is fine), but
agreed to send over a refund due to the drain plug incident.

It was weird to be back in Woustviller after all this time. Well, not much time, but it felt like an
aeon. Much thinking has been done. I went back to the [Kebab Le
Bosphore](https://maps.app.goo.gl/BZDovZ6r6yfJkxV49), and finished hammering out support for the
natural numbers. As the last axioms for GT3 fell into place, it was closing time, and time for me to
ride to Calais, lest I miss sushi. So we hit the road.

Gas stations are dangerous. It seems that the closer I go to where I was forged, the more powerful I
become. Once more, I find myself waylaid by my dastardly foe. At 3 AM, I decide just to sleep there.
Attendant was a cool guy. Lots of food, warm, and open all night. Like a little mall.

It's 6 AM, I'm up, I get some food, and we have precisely 12 hours to be ready for London. 

We ride for Calais! For the first time since I began this journey, I crack a monster: "Top Speed,"
the French version of Lewis Hamilton flavor. Already, we're coming home.

The ride home is not uneventful. But I make it to the train, with some time to spare, and take an
early instance of Le Shuttle. Through the tunnel, and it's an easy ride to London, back on the wrong
side of the road. There's a dress code, but I have just enough time to shower and go buy a shirt
from Marks & Spencer. I'm on three hours of sleep, but I've survived worse.

I have a good time, enjoying the last brief period of rest before the excellently-named
[HOPE](https://conf.researchr.org/home/icfp-splash-2025/hope-2025#event-overview), followed by the
Thesis March.

The morning comes, we have a nice late breakfast of chicken at [Pitted
Olive](https://maps.app.goo.gl/oyxJrjrJpzrz54g48). And then I ride back to Cambridge.

Ten mostly uneventful days followed, as I sorted various things out and got back on track for
thesis, teaching, et al.

It is 2025-09-29T10:48+1. A long time ago, my father remarked that the garden behind Darwin was
about as close a representation of Eden as one could get on Earth. I've warmed to this sentiment.

So I'm standing under the Tree of Knowledge of Good and Evil, a year and a month, or a year, later,
and, I reflect that, as Steve Jobs might say, it's time to become a real artist, and ship.

# Inductive SSA

_Location_: [FS04, William Gates Building](https://maps.app.goo.gl/vE5oxXW5XHdiGybq5) (52.210434,
0.091859)

_Time_: 2025-09-30T18:19+1

As I was just saying, a while back, I [wrote an article on building an inductive representation of
SSA](http://tekne.dev/blog/building-inductive-ssa), which later became the core of my TOPLAS
submission, [_The Denotational Semantics of SSA_](https://arxiv.org/abs/2411.09347), which must now
become the core of my thesis. It's time to work on shipping that.

Recall that a program written in 3-address code consists of a _control-flow graph_ $G$ made up of
basic blocks $β$. Each basic block is a straight-line sequence of _instructions_ (often of the form
$x = \mathsf{op}(y, z)$, hence the name three-address code) followed by a single _terminator_
instruction, which can jump to other basic blocks. Examples of terminators might be an unconditional
jump to a label $ℓ$, or a conditional branch (if-then-else). By convention, we'll assume $G$ has a
distinguished _entry block_ without a label.

So, to compute `10!`, we might write the C program
```rust
let n = 10;
let mut i = 1;
let mut a = 1;
while i < 10 {
    a *= (i + 1);
    i += 1;
}
```
We could compile this to three-address code to get
```c
    n = 10;
    i = 1;
    a = 1;
    goto loop;
loop:
    if (i < n) { goto body } 
    else { return a };
body:
    t = i + 1;
    a = a * t;
    i = i + 1;
    goto loop
```
Which blocks can _syntactically_ jump to each other form the (directed) edges in the CFG. So for
example, this CFG has edges
```c
ENTR -> loop
loop -> body
loop -> EXIT
body -> loop
```
We might make this into a formal grammar as follows:
```c
// Instructions
//
// We allow a variable as an instruction for renaming
o ::= op x₁ ... xₙ | x
// Basic blocks
β ::= x₁,...,xₙ = o; β | τ
// Terminators
τ ::= goto ℓ | if o { τ₁ } else { τ₂ } | return o
// Control-flow graphs
//
// Note: the entry block is first
G ::= β | G ; ℓ : β
```
Note constants $c$ are just nullary operations `op`; we allow the if-statements in terminators to be
nested for simplicity, and also because that can be used to emulate a `switch`.

There are three regularizing tweaks we might want to make as type theorists:
- Introduce nullary tuples $()$ and binary tuples $(v, v')$ of values, and make operations take a
  single tuple $v$, likeso:
    ```c
    // Tuples
    v ::= x | (v₁, v₂) | ()
    // Instructions
    o ::= op v
    ```
  An $n$-ary tuple can then be implemented as just $(x_1, (x_2, (x_3, ...)))$ (or we can associate
  on the left, of course). Then we can regularize our let-bindings as
  ```c
  // Basic blocks
  β ::= x = o; β | (x, y) = o; β | τ
  ```
  which of course we can use to desugar any pattern destructure $v = o; β$ in the obvious manner.
  This avoids tedious work with $n$-ary shifts to our de-Bruijn indices when using those, since
  adding one and two has _much_ better defeqs.

  We _do_ do this in both our SSA papers[^2]. We're _not_ _quite_ going to do this here, yet. But
  keep it in mind.

- Replace `return` with a branch to a distinguished exit label; with `return` now just syntax sugar.
- Replace if-then-else with case-statements `case (o) { ι₁ x₁ : τ₁ ; ι₂ x₂ : τ₂ }` 
  (if-then-else just desugars to an anonymous case split on $1 + 1$).

  Well, our paper does binary case-statements, but this in fact leads to suffering later when we
  want to prove things like completeness and Böhm-Jacopini, so we'll learn from that and do an
  $n$-ary statement. Because I am unfathomably lazy and want to use my C syntax highlighter, we'll
  keep the keyword `switch`[^3], and so write `switch (o) { ι₁ x₁ : τ₁ ; ... ; ιₙ xₙ : τₙ }`.

  In the paper, injections become part of the grammar for instructions $o$. Here, we're going to be
  lazy and say injections become part of `op`; nullary injections (we'll write these $ιₙ\;()$ for
  disambiguation) for components of unit type, and unary in general. We might need to tag them with
  types, or something. We're being lazy here because we have a different goal in this section than
  in the paper.

We'll do the latter two only. So terminators become
```c
// Terminators
τ ::= goto ℓ | switch (o) { ι₁ x₁ : τ₁ ; ... ; ιₙ xₙ : τₙ }
```
Now, SSA can be viewed as a _property_ of a 3-address program: every variable name $x$ having
precisely one definition; i.e. _static single assignment_[^4]. If a 3-address program has no
variables whose value is (syntactically) control-flow dependent, we can re-name variables
(essentially, appending a time-stamp) to convert it to an equivalent program in SSA; e.g.
```c
    x = y + z;
    x = x + 3;
    if (x > 3) { return 5 } else { goto rest };
rest:
    x = 3 + y;
    return x;
```
becomes
```c
    x₀ = y + z;
    x₁ = x₀ + 3;
    if (x₁ > 3) { return 5 } else { goto rest };
rest:
    x₂ = 3 + y;
    return x₂
```
The idea is we're just numbering each syntactic re-definition of $x$, and then replacing each use
with the specific definition it is referring to, where "John" is replaced with "John Smith" or "John
Doe" based on context. But not every program is unambiguous with respect to control-flow:
```c
    if (φ) { goto left } else { goto right };
left:
    x = 3;
    goto then;
right:
    x = 5;
    goto then;
then:
    return x;
```
If $x₀ = 3$ and $x₁ = 5$, which $x$ are we returning? Standard SSA solves this by introducing
special _$ϕ$-instructions_ or $ϕ$-nodes which take a different value depending on where we just came
from in the CFG. So for example, since if we came from `left` we'd use $x₁$, but use $x₂$ if we came
from `right`, we could introduce a $ϕ$-instruction representing this as follows:
```c
    if (φ) { goto left } else { goto right };
left:
    x₀ = 3;
    goto then;
right:
    x₁ = 5;
    goto then;
then:
    x₂ = ϕ { left : x₀ ; right : x₁ }
    return x;
```
Often, we allow pure operations, or at least constants, in $ϕ$-instructions, so we could even
simplify this to
```
if (φ) { goto left } else { goto right };
left:
    goto then;
right:
    goto then;
then:
    x₂ = ϕ { left : 3 ; right : 5 }
    return x;
```
These have slightly unintuitive scoping rules: we can add a label $ℓ : o$ to a $ϕ$-instruction if
$o$ would be well-scoped at the _end_ of the basic-block $β$ labelled $ℓ$[^5]. We'll maintain the
invariant that $ϕ$-instructions _cannot_ access other variables in _their own_ block (so the scope
is _precisely_ that at the end of $β$, rather than the union of the instructions before the
$ϕ$-instruction and those visible at the end of $β$); since $ϕ$-instructions are pure, we can also
easily maintain the invariant that $ϕ$-instructions are always before any non-$ϕ$ instruction in
their basic block by simply floating them up to the top[^6].

Thankfully, by a mechanical transformation, we can show that $ϕ$-instructions are precisely
equivalent to simply giving every label 


[^1]: I was very confused, as the captain kept saying we were going to "Volcano Island." Which
    volcano?

[^2]: I'll stick a link here when the second paper is on the arxiv; the LaTeX source is with the
      rest of our ongoing SSA research at https://github.com/isotope-project/ssa-densem 

[^3]: Note that the paper uses `br`, but we're using `goto` here. That's why. I've also switched
      commas to semicolons, so it really does look like a C switch if labels took arguments, and
      labels don't get a color so far so it all works out.

[^4]: Static since we're talking about syntactic (static) definition; dynamically, that single
    definition might be run plenty of times and receive a different value each time (e.g. $x =
    read_int()$ in a loop)

[^5]: Based on _dominance-based scoping_, as explained in the [previous
    article](http://tekne.dev/blog/building-inductive-ssa), but to understand this, all you need to
    know is that this is just whatever scoping we use in 3-address code

[^6]: What we're about to say is still true if the first invariant; that $ϕ$-instructions _cannot_
    access other variables in _their own_ block; is _not_ maintained, but then things get a bit more
    complicated, as we need to move any instructions depended on by that $ϕ$-instructions into each
    of the source blocks $ℓ$, disambiguating any $ϕ$-instructions we pull in by replacing them with
    their $ℓ$-branch as we go along. This is ugly, and might lead to a larger program, and in
    general is harder to analyze. So let's not.

    On the other hand, if we have the _second_ invariant, we only need to slightly modify the
    basic-blocks-with-arguments transformation by, for any $ϕ$-instructions referenced by a later
    $ϕ$-instruction in a given $ℓ$-branch, introducing a temporary and using that. Unlike before,
    this only adds a constant factor to program size, so it's a Real Isomorphism (TM) even on the
    syntactic level, kind of (it's not quite a syntactic round-trip anymore, unfortunately).

    Note that an extremely (to understate things) popular SSA-based IR, LLVM, according to the spec,
    [maintains at least the second invariant](https://llvm.org/docs/LangRef.html#phi-instruction).

    But we assume the first invariant since, while my (very cursory reading) says that the LLVM spec
    does not actually guarantee it (only the second), but I'd say code not satisfying both
    properties is at least highly unidiomatic, and I like simplicity and syntactic isomorphisms. But
    as said in the paragraph as long as we have the second invariant whether or not we have the
    first invariant does not change much!

<script>
    import boat_circle from "$lib/assets/temporary.jpg"
    import conad_seafood from "$lib/assets/temporary.jpg"
    import roman_pasta from "$lib/assets/temporary.jpg"
</script>
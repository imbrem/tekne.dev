---
title: Undefined Behavior vs. Poison
published: '2025-01-06'
---

To make compiler optimizations tractable, compilers will often make the assumption that "invalid
things don't happen." This can often lead to surprising behavior when programs are generated by
fallible entities such as humans and, more recently, stochastic parrots. 

For example, division by zero in C is [_undefined
behavior_](https://en.wikipedia.org/wiki/Undefined_behavior) (_UB_), and therefore the optimizer is
free to convert
```c
y = 3 / x;
if (x == 0) {
    return 5;
}
return y;
```
to
```c
y = 3 / x;
return y;
```
since we can assume that `x` is nonzero (as otherwise execution would trigger UB).

While UB makes it easier to perform more aggressive optimizations, it also makes it much harder to
write safe programs. It turns out, however that UB can also make it more difficult to write
_correct_ optimizations. For example, since division can cause UB, it is _not_ a pure operation:
we can rewrite
```c
y = 3 / x;
if (x == 0) {
    return 5;
}
return y;
```
to
```c
if (x == 0) {
    return 5;
}
y = 3 / x;
return y;
```
but _not_ vice versa, since the former has UB when `x == 0` (and therefore it is perfectly valid to
return `5`), but the latter never exhibits UB. This is an example of a _refinement_, in which we
_shrink_ the set of allowable behaviors a program may exhibit.

Bugs in which compilers themselves introduce UB (which later phases of the compiler then might turn
into miscompilations!) are unfortunately common. A good example I like to go over with my students
for [Optimizing Compilers](https://www.cl.cam.ac.uk/teaching/2425/OptComp/) supervisions is [part
(b) of 2004 Paper 8 Question 7](https://www.cl.cam.ac.uk/teaching/exams/pastpapers/y2004p8q7.pdf),
which asks students to optimize the following:
```c
extern int u[100],v[100],w[100];
void f(int n)
{   int i, y = ..., z = ...;
    for (i=5; i<n; i++)
    {   u[i] += 1000/y;
        v[i] += 1000/z;
        p(&y);
        w[i] += 1000/z;
    }
}
```
using loop-invariant lifting. The astute reader may note that, if `n <= 5`, the code in the for-loop
will never run. The most common solution (and the one in the notes) is to optimize this program to
```c
extern int u[100],v[100],w[100];
void f(int n)
{   int i, y = ..., z = ...;
    int t = 1000 / z;
    for (i=5; i<n; i++)
    {   u[i] += 1000/y;
        v[i] += t;
        p(&y);
        w[i] += t;
    }
}
```
correctly noting that `p` may change `y` and therefore that the expression `1000/y` cannot be
hoisted. I have, however, never seen the pedantic note that `z` must be nonzero for this
transformation to be valid included, which would be a problem if, e.g., `z = n - 3` (or, for that
matter, `z = 0`), since in this case calling the optimized `f(3)` would yield UB, whereas the
original function would do nothing.

While it might be unintuitive to think of an arithmetic operation as side-effecting, this actually
coincides with the behavior of assembly and many high-level languages alike. In Python, executing
```python
y = 3 / x
if x == 0:
    return 5
return y
```
with `x = 0` throws a
[`ZeroDivisonError`](https://docs.python.org/3/library/exceptions.html#ZeroDivisionError), while 
```python
if x == 0:
    return 5
y = 3 / x
return y
```
returns 5; similarly, on x86, [division by zero generates a #DE
exception](https://www.felixcloutier.com/x86/div).

Division by zero is not the only way to get UB doing arithmetic in C, however. Signed integer
overflow is _also_ undefined behavior: 
```c
int32_t x = 1 << 30;
x *= 16; // UB!
```
_Unsigned_ integer overflow, of course, is fine. This enables us to do [even more
optimizations](https://kristerw.blogspot.com/2016/02/how-undefined-signed-overflow-enables.html),
though it may not be the best idea security-wise. However, it turns out to be a terrible idea for
an _intermediate representation_ to have every arithmetic operation be potentially side-effecting.
After all, we want to be able to optimize
```c
extern int u[100],v[100],w[100];
void f(int n)
{   int i, y = ..., z = ...;
    for (i=5; i<n; i++)
    {   u[i] += 1000/y;
        v[i] += 1000 + z;
        p(&y);
        w[i] += 1000 + z;
    }
}
```
to
```c
extern int u[100],v[100],w[100];
void f(int n)
{   int i, y = ..., z = ...;
    int t = 1000 + z;
    for (i=5; i<n; i++)
    {   u[i] += 1000/y;
        v[i] += t;
        p(&y);
        w[i] += t;
    }
}
```
even if `z` might be a very very large number. Since arithmetic other than division generally does
not trap...

undefined value vs undefined behaviour...

limited optimizations...

specially handled undefined value: `poison` and `undef`;
[presentation](https://llvm.org/devmtg/2020-09/slides/Lee-UndefPoison.pdf)

freeze to go down to an actual set

hierarchy of definedness, some optimizations we can do for each level

undef elimination; find link, will focus on poison

# Modeling UB with Option

The `Option` monad

Trivial enough, works nicely, has expected semantics

How can we think about refinement? Sort of works...

Kleisli category is a 2-poset!

One issue: this doesn't demonstrate the sliding refinement property

Solution: apply `ExceptT` monad transformer, now it does! Still a 2-poset, now _premonoidal_
rather than _monoidal_. So we need to draw wires in our diagrams.

# Modeling Poison with Option

Poison doesn't work in the Kleisli category since poison slides but UB does not, so we need to do it
in the base category, like in Rust's
[`MaybeUninit`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html)

Also sort of works

But...
- Too many functions allowed (e.g. non constant maps out of poison)
- And yet, no freeze

Want something like Rust's
[`MaybeUninit`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html), rather than
[`Option`](https://doc.rust-lang.org/std/option/): pattern matching is forbidden, though freeze and
constants work

This all _should_ work, without much changes. But how?

Let's switch categories!

# Modeling Poison with WithTop

The `WithTop` monad is a monad in the category of posets; it's what we were secretly using by
mapping sets to their corresponding discrete posets.

Refinement structure comes from the fact that the category of posets is a 2-poset

But no `freeze`

# Modeling Freeze with NSet

So, let's try `WithTopT NSet` for `MaybeUninit`, i.e. $\mathcal{P}^+(A) \cup \{\top\}$.

Works (original is in fact a _submonad_)

And it freezes!

Remember, a map needs to be _monotone_, not _increasing_!

# Modeling UB with WithTop

Can model UB as the Kleisli category of `ExceptT E WithTop`

Now, we also get higher-order reasoning for free!

Differences with poison:
- We can discard poison, but we can't discard UB
- We can slide poison, but we can't slide UB (i.e. category is premonoidal, again)

# Combining UB and Poison

Not particularly hard, since `MaybeUninit` is a perfectly valid object in the UB category

TODO: is it in fact a _monad_ in the UB category?

# Conclusion

We've now got a simple mathematical model of poison and UB

- Exercise: add a heap to the UB monad using a state transformer; show things still work
- Exercise: allow putting poison in the UB monad's heap; show things still work

Next time, we'll think about

- Modeling nontermination, "A Tale of Two Elgot Structures"
- Fun things about loops without side-effects